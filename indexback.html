<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Gboard Editor</title>
      <style>
         html {
         overflow: auto;
         /* Hide scroll */
         scrollbar-width: none;
         /* Firefox */
         -ms-overflow-style: none;
         /* IE and Edge */
         }
         html::-webkit-scrollbar {
         display: none;
         /* Chrome, Safari */
         }
         :root {
         --primary: #46526b;
         --primary-hover: #1742a0;
         --bg: #f7f9fc;
         --card: #ffffff;
         --radius: 8px;
         --input-bg: #eef2f7;
         --input-focus: #e0e7ef;
         --border: #dbeafe;
         --highlight: #fff7cc;
         --highlight-text: #bfa31d;
         --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
         --toast-bg: #333;
         --toast-color: #fff;
         }
         * {
         box-sizing: border-box;
         margin: 0;
         padding: 0;
         }
         body {
         font-family: 'Segoe UI', Arial, sans-serif;
         background: var(--bg);
         color: #222;
         display: flex;
         justify-content: center;
         align-items: flex-start;
         min-height: 100vh;
         padding: 20px 0;
         }
         .container {
         width: 100%;
         max-width: 900px;
         background: var(--card);
         border-radius: var(--radius);
         padding: 24px;
         box-shadow: var(--shadow);
         display: flex;
         flex-direction: column;
         gap: 20px;
         }
         h2 {
         font-size: 2rem;
         color: var(--primary);
         text-align: center;
         font-weight: 700;
         }
         h3 {
         font-size: 1.1rem;
         color: #222;
         margin-bottom: 8px;
         }
         input,
         textarea,
         button {
         font-family: monospace;
         font-size: 15px;
         }
         textarea,
         input[type="text"] {
         width: 100%;
         padding: 12px 14px;
         border-radius: var(--radius);
         border: 1px solid var(--border);
         background: var(--input-bg);
         transition: all 0.2s ease;
         }
         textarea {
         min-height: 220px;
         resize: vertical;
         box-shadow: 0 2px 10px rgba(37, 99, 235, 0.05);
         overflow-x: auto;
         white-space: nowrap;
         }
         textarea:focus,
         input:focus {
         outline: none;
         background: var(--input-focus);
         }
         .file-upload,
         .actions,
         .input-group {
         display: flex;
         gap: 10px;
         flex-wrap: wrap;
         justify-content: center;
         }
         .file-upload input[type="file"] {
         display: none;
         }
         .btn {
         background: var(--primary);
         color: #fff;
         border: none;
         border-radius: var(--radius);
         padding: 10px 18px;
         cursor: pointer;
         font-weight: 600;
         transition: 0.2s ease;
         box-shadow: 0 2px 10px rgba(37, 99, 235, 0.1);
         }
         .btn:hover {
         background: var(--primary-hover);
         }
         #preview {
         max-height: 300px;
         overflow: auto;
         background: var(--input-bg);
         padding: 10px;
         border-radius: var(--radius);
         font-size: 14px;
         white-space: nowrap;
         margin-top: 10px;
         }
         #preview div {
         padding: 4px;
         border-radius: 6px;
         transition: 0.2s;
         }
         #preview div:hover {
         background: #f0f4ff;
         }
         #preview .shortcut {
         font-weight: 700;
         display: inline-block;
         padding-right: 8px;
         }
         #preview .highlight {
         background: var(--highlight);
         color: var(--highlight-text);
         font-weight: 700;
         }
         #preview .selected {
         background: linear-gradient(90deg, #cce5ff, #99ccff);
         color: #003366;
         font-weight: 700;
         transition: background 0.3s, color 0.3s;
         border-left: 4px solid #3366cc;
         padding-left: 6px;
         border-radius: 6px;
         }
         #stats {
         text-align: right;
         font-size: 0.9rem;
         color: #444;
         margin-top: 4px;
         }
         #toast {
         position: fixed;
         bottom: 24px;
         left: 50%;
         transform: translateX(-50%);
         background: var(--toast-bg);
         color: var(--toast-color);
         padding: 12px 20px;
         border-radius: 6px;
         opacity: 0;
         pointer-events: none;
         transition: opacity 0.3s ease;
         z-index: 9999;
         }
         #toast.show {
         opacity: 1;
         pointer-events: auto;
         }
         @media (max-width: 768px) {
         .container {
         padding: 20px 16px;
         }
         textarea,
         input[type="text"] {
         font-size: 14px;
         }
         .btn {
         font-size: 14px;
         padding: 10px 14px;
         }
         }
         @media (max-width: 480px) {
         .container {
         padding: 16px 12px;
         }
         h2 {
         font-size: 1.2rem;
         }
         textarea,
         input[type="text"] {
         font-size: 13px;
         padding: 8px;
         }
         .btn {
         font-size: 13px;
         padding: 8px 12px;
         width: 100%;
         }
         .actions .btn {
         flex: 1 1 35%;
         }
         #preview {
         margin-top: 10px;
         }
         #preview .shortcut[data-prefix="a"] {
         color: #ff4500;
         font-weight: 700;
         }
         }
         #alphabetBar {
         display: flex;
         flex-wrap: wrap;
         justify-content: center;
         gap: 6px;
         margin-top: 10px;
         padding: 8px;
         background: #eef2f7;
         border-radius: 6px;
         }
         #alphabetBar span {
         font-size: 13px;
         font-weight: 600;
         color: #46526b;
         cursor: pointer;
         transition: 0.2s;
         user-select: none;
         }
         #alphabetBar span:hover {
         color: #1742a0;
         transform: scale(1.2);
         }
         @media (max-width: 600px) {
         #alphabetBar {
         gap: 4px;
         padding: 6px;
         }
         #alphabetBar span {
         font-size: 11px;
         }
         }
         .new-entry {
         color: #000000 !important;
         /* dark yellow */
         background-color: #07ff77 !important;
         /* light green */
         }
         .edited-entry {
         color: gold;
         background-color: #ff0015 !important;
         /* light red */
         }
      </style>
   </head>
   <body>
      <div class="container">
         <h2>üìÇ Gboard Dictionary Editor</h2>
         <!-- File Upload -->
         <div class="file-upload">
            <input type="file" id="fileInput" accept=".txt,.zip">
            <button class="btn" id="fileBtn">üìÇ Choose File</button>
            <span id="fileName"></span>
         </div>
         <!-- Text Area -->
         <textarea id="textArea" placeholder="Your file content will appear here..." spellcheck="false"></textarea>
         <!-- Action Buttons -->
         <div class="actions">
            <button class="btn" onclick="sortLines()">Sort üîÄ</button>
            <button class="btn" onclick="removeEmptyLines()">Space üóëÔ∏è</button>
            <button class="btn" onclick="removeDuplicates()">Duplicate üìë</button>
            <button class="btn" onclick="removeExtraSpaces()">Clean ‚ùå</button>
            <button class="btn" onclick="downloadFile()">Txt ‚¨á</button>
            <button class="btn" onclick="downloadZip()">Zip ‚¨á</button>
            <!-- üÜï Telegram Upload Button -->
            <button class="btn" onclick="sendToTelegram()">üì§ TG </button>
            <button class="btn" onclick="goToLastChange()">üü¢ Last Change</button>
         </div>
         <!-- Add Entry -->
         <div class="input-group">
            <input type="text" id="shortcutInput" placeholder="Shortcut" style="flex:0 0 30%;">
            <input type="text" id="valueInput" placeholder="Value" style="flex:1;">
            <button class="btn" onclick="addEntry()" style="flex:0 0 auto;">Add ‚ûï</button>
         </div>
         <!-- Filter Section -->
         <div class="input-group">
            <input type="text" id="shortcutFilter" placeholder="üîç Shortcut..." list="shortcutSuggestions"
               style="flex:0 0 30%;">
            <input type="text" id="valueFilter" placeholder="üîç Value..." list="valueSuggestions" style="flex:1;">
            <button class="btn" onclick="clearFilters()" style="flex:0 0 auto;">Filter ‚ùå</button>
         </div>
         <!-- Preview Section -->
         <div class="preview-section">
            <h3>üìù Final Preview</h3>
            <div class="input-group">
               <input type="text" id="editShortcut" placeholder="Edit Shortcut" style="flex:0 0 30%;">
               <input type="text" id="editValue" placeholder="Edit Value" style="flex:1;">
               <button class="btn" id="applyEditBtn" style="flex:0 0 auto;">Apply ‚úîÔ∏è</button>
               <button class="btn" id="deleteBtn" style="flex:0 0 auto;">Delete ‚ùå</button>
            </div>
            <div id="preview"></div>
            <div id="stats"></div>
            <div id="alphabetBar"></div>
            <datalist id="shortcutSuggestions"></datalist>
            <datalist id="valueSuggestions"></datalist>
         </div>
      </div>
      <div id="toast"></div>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
      <script>
         // -----------------------------
         // Variables
         // -----------------------------
         const fileInput = document.getElementById('fileInput');
         const textArea = document.getElementById('textArea');
         const preview = document.getElementById('preview');
         const shortcutInput = document.getElementById('shortcutInput');
         const valueInput = document.getElementById('valueInput');
         const shortcutFilter = document.getElementById('shortcutFilter');
         const valueFilter = document.getElementById('valueFilter');
         const editShortcut = document.getElementById('editShortcut');
         const editValue = document.getElementById('editValue');
         const applyEditBtn = document.getElementById('applyEditBtn');
         const stats = document.getElementById('stats');
         const fileBtn = document.getElementById('fileBtn');
         const fileName = document.getElementById('fileName');
         const deleteBtn = document.getElementById('deleteBtn');
         const toast = document.getElementById('toast');
         
         let filteredLines = [];
         let selectedIndex = -1;
         let scrollToSelected = true;
         
         // -----------------------------
         // Utility Functions
         // -----------------------------
         function showToast(msg) {
             toast.textContent = msg;
             toast.classList.add('show');
             setTimeout(() => { toast.classList.remove('show'); }, 2000);
         }
         
         function escapeHtml(text) {
             return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
         }
         
         // -----------------------------
         // Preview Update
         // -----------------------------
         function updatePreview() {
             const lines = textArea.value.split('\n');
             const counts = {};
             lines.forEach(line => {
                 const sc = line.split('\t')[0];
                 if (sc) counts[sc] = (counts[sc] || 0) + 1;
             });
         
             const sFilter = shortcutFilter.value.toLowerCase();
             const vFilter = valueFilter.value.toLowerCase();
             filteredLines = lines.filter(line => {
                 const parts = line.split('\t');
                 return (parts[0]?.toLowerCase().includes(sFilter) && parts[1]?.toLowerCase().includes(vFilter));
             });
         
             // Store previous classes
             const prevClasses = [];
             Array.from(preview.children).forEach(div => {
                 prevClasses.push({
                     sc: div.querySelector(".shortcut")?.textContent,
                     cls: div.className
                 });
             });
         
             preview.innerHTML = filteredLines.map((line, i) => {
                 const parts = line.split('\t');
                 const sc = parts[0] || '', val = parts[1] || '';
                 const isDup = counts[sc] > 1, isSelected = i === selectedIndex;
         
                 // Check previous class
                 const prev = prevClasses.find(p => p.sc === sc);
                 let cls = isSelected ? 'selected' : '';
                 if (isDup) cls += ' highlight';
                 if (prev) cls += ' ' + prev.cls.replace('selected', '').replace('highlight', '').trim();
         
                 return `<div class="${cls}">
             <span class="shortcut">${escapeHtml(sc)}</span>\t
             <span class="value">${escapeHtml(val)}</span>
         </div>`;
             }).join('');
         
             let dup = 0;
             for (let k in counts) if (counts[k] > 1) dup += counts[k] - 1;
         
             const lineNumberText = selectedIndex >= 0 ? `Line Number: ${selectedIndex + 1} | ` : '';
             stats.textContent = `${lineNumberText}Total Lines: ${lines.length} | Duplicate Shortcuts: ${dup}`;
         
             updateEditableFields();
         
             if (scrollToSelected && selectedIndex >= 0) {
                 const child = preview.children[selectedIndex];
                 if (child) {
                     preview.scrollTop = child.offsetTop - preview.offsetTop;
                 }
             }
             scrollToSelected = true;
         }
         
         function updateEditableFields() {
             if (selectedIndex >= 0 && filteredLines[selectedIndex]) {
                 const parts = filteredLines[selectedIndex].split('\t');
                 editShortcut.value = parts[0] || '';
                 editValue.value = parts[1] || '';
             } else {
                 editShortcut.value = '';
                 editValue.value = '';
             }
         }
         
         // -----------------------------
         // File Handling
         // -----------------------------
         fileBtn.addEventListener('click', () => fileInput.click());
         
         fileInput.addEventListener('change', () => {
             if (fileInput.files.length > 0) {
                 // Hide the Choose File button
                 fileBtn.style.display = 'none';
         
                 // Show file name nicely
                 fileName.style.display = 'inline-block';
                 fileName.textContent = fileInput.files[0].name;
                 fileName.style.fontWeight = '600';
                 fileName.style.color = '#1742a0';
                 fileName.style.marginLeft = '10px';
             } else {
                 fileBtn.style.display = 'inline-block';
                 fileName.style.display = 'none';
             }
         
             const file = fileInput.files[0];
             if (!file) return;
         
             const reader = new FileReader();
         
             if (file.name.endsWith('.txt')) {
                 reader.onload = e => {
                     textArea.value = e.target.result;
                     updatePreview();
                     updateSuggestions();
                 };
                 reader.readAsText(file);
             } else if (file.name.endsWith('.zip')) {
                 reader.onload = e => {
                     JSZip.loadAsync(e.target.result).then(zip => {
                         const dictFile = zip.file("dictionary.txt");
                         if (dictFile) {
                             dictFile.async("string").then(content => {
                                 textArea.value = content;
                                 updatePreview();
                                 updateSuggestions();
                             });
                         } else showToast("Zip file-‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá dictionary.txt ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø!");
                     });
                 };
                 reader.readAsArrayBuffer(file);
             }
         });
         
         
         function updateSuggestions() {
             const lines = textArea.value.split('\n');
             const sSet = new Set(), vSet = new Set();
         
             lines.forEach(line => {
                 const p = line.split('\t');
                 if (p[0]) sSet.add(p[0].trim());
                 if (p[1]) vSet.add(p[1].trim());
             });
         
             const shortcutList = document.getElementById('shortcutSuggestions');
             const valueList = document.getElementById('valueSuggestions');
             shortcutList.innerHTML = '';
             valueList.innerHTML = '';
         
             Array.from(sSet).sort().forEach(s => {
                 const opt = document.createElement('option');
                 opt.value = s;
                 shortcutList.appendChild(opt);
             });
         
             Array.from(vSet).sort().forEach(v => {
                 const opt = document.createElement('option');
                 opt.value = v;
                 valueList.appendChild(opt);
             });
         }
         
         // -----------------------------
         // Line Operations
         // -----------------------------
         function removeEmptyLines() {
             textArea.value = textArea.value.split('\n').filter(l => l.trim() !== '').join('\n');
             updatePreview();
             updateSuggestions();
             showToast("Empty lines removed!");
         }
         
         function removeDuplicates() {
             const seen = new Set();
             textArea.value = textArea.value.split('\n').filter(l => {
                 const sc = l.split('\t')[0];
                 if (seen.has(sc)) return false;
                 seen.add(sc);
                 return true;
             }).join('\n');
             updatePreview();
             updateSuggestions();
             showToast("Duplicates removed!");
         }
         
         function removeExtraSpaces() {
             const lines = textArea.value.split('\n');
             const cleaned = lines.map(line => line.split('\t').map(p => p.trim()).join('\t'));
             textArea.value = cleaned.join('\n');
             updatePreview();
             updateSuggestions();
             showToast("Extra spaces and tabs cleaned!");
         }
         
         function sortLines() {
             const lines = textArea.value.split('\n');
             const comments = lines.filter(l => l.trim().startsWith('#'));
             const normal = lines.filter(l => !l.trim().startsWith('#'));
             normal.sort((a, b) => a.localeCompare(b));
             textArea.value = [...comments, ...normal].join('\n');
             updatePreview();
             updateSuggestions();
             showToast("Lines sorted!");
         }
         
         // -----------------------------
         // Add / Edit / Delete
         // -----------------------------
         // üîπ Track last changed line
         let lastChangedIndex = -1;
         
         // addEntry function update
         function addEntry() {
             const sc = shortcutInput.value.trim();
             const val = valueInput.value.trim();
             if (!sc || !val) return showToast('Enter both shortcut and value!');
         
             textArea.value += (textArea.value ? '\n' : '') + `${sc}\t${val}\ten-US\t`;
             shortcutInput.value = valueInput.value = '';
             updatePreview();
             updateSuggestions();
             shortcutInput.focus();
             showToast("Entry added!");
         
             selectedIndex = filteredLines.length - 1; // last line
             lastChangedIndex = selectedIndex;         // üîπ update last changed
             const newDiv = preview.children[selectedIndex];
             if (newDiv) newDiv.classList.add('new-entry');
         }
         
         // applyEditBtn click update
         applyEditBtn.addEventListener('click', () => {
             if (selectedIndex < 0) return showToast("No line selected!");
             const lines = textArea.value.split('\n');
             const targetLine = filteredLines[selectedIndex];
             const indexInAll = lines.indexOf(targetLine);
             if (indexInAll < 0) return;
             lines[indexInAll] = `${editShortcut.value}\t${editValue.value}\ten-US\t`;
             textArea.value = lines.join('\n');
             updatePreview();
             updateSuggestions();
             showToast("Line updated!");
         
             const editedDiv = preview.children[selectedIndex];
             if (editedDiv) {
                 editedDiv.classList.remove('new-entry');
                 editedDiv.classList.add('edited-entry');
                 lastChangedIndex = selectedIndex; // üîπ update last changed
             }
         });
         
         // üîπ New function to jump to last added/edited line
         function goToLastChange() {
             if (lastChangedIndex >= 0 && lastChangedIndex < filteredLines.length) {
                 selectedIndex = lastChangedIndex;
                 scrollToSelected = true;
                 updatePreview();
                 updateEditableFields();
                 showToast("Jumped to last added/edited line!");
             } else {
                 showToast("No last change to jump to!");
             }
         }
         
         
         function deleteEntry() {
             if (selectedIndex < 0) return showToast("No line selected!");
             const lines = textArea.value.split('\n');
             const targetLine = filteredLines[selectedIndex];
             const indexInAll = lines.indexOf(targetLine);
             if (indexInAll >= 0) {
                 lines.splice(indexInAll, 1);
                 textArea.value = lines.join('\n');
                 selectedIndex = -1;
                 updatePreview();
                 updateSuggestions();
                 showToast("Selected line deleted!");
             }
         }
         
         deleteBtn.addEventListener('click', deleteEntry);
         
         // -----------------------------
         // Keyboard Shortcuts
         // -----------------------------
         window.addEventListener('keydown', e => {
             if (e.ctrlKey && e.key.toLowerCase() === 's' && !e.shiftKey) { e.preventDefault(); downloadFile(); }
             if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 's') { e.preventDefault(); downloadZip(); }
             if (e.ctrlKey && e.key.toLowerCase() === 'd') { e.preventDefault(); removeDuplicates(); }
             if (e.ctrlKey && e.key.toLowerCase() === 'e') { e.preventDefault(); removeEmptyLines(); }
             if (e.ctrlKey && e.key.toLowerCase() === 'k') { e.preventDefault(); removeExtraSpaces(); }
             if (e.ctrlKey && e.key.toLowerCase() === 'l') { e.preventDefault(); sortLines(); }
             if (e.key === "Delete") { e.preventDefault(); deleteEntry(); }
             if ((document.activeElement === editShortcut || document.activeElement === editValue) && e.key === "Enter") {
                 e.preventDefault(); applyEditBtn.click();
             }
             if (e.ctrlKey && e.key.toLowerCase() === 'o') { e.preventDefault(); fileInput.click(); }
         });
         
         // -----------------------------
         // Filters & Suggestions
         // -----------------------------
         shortcutFilter.addEventListener('input', () => { selectedIndex = -1; updatePreview(); updateSuggestions(); });
         valueFilter.addEventListener('input', () => { selectedIndex = -1; updatePreview(); updateSuggestions(); });
         
         function clearFilters() {
             shortcutFilter.value = valueFilter.value = '';
             selectedIndex = 0; // ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶≤‡¶æ‡¶á‡¶®‡ßá ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ
             scrollToSelected = true; // ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶≤ ‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶∞‡¶æ‡¶ñ‡¶æ
             updatePreview();
             updateSuggestions();
             showToast("Filters cleared!");
         }
         
         
         // -----------------------------
         // TextArea Click
         // -----------------------------
         function updateEditableFromTextarea() {
             const cursorPos = textArea.selectionStart;
             const lines = textArea.value.split('\n');
             let cumulative = 0, lineIndex = 0;
             for (let i = 0; i < lines.length; i++) {
                 cumulative += lines[i].length + 1;
                 if (cursorPos <= cumulative) { lineIndex = i; break; }
             }
             const line = lines[lineIndex];
             const fi = filteredLines.indexOf(line);
             selectedIndex = fi >= 0 ? fi : -1;
             updatePreview();
             updateEditableFields();
         }
         
         textArea.addEventListener('click', updateEditableFromTextarea);
         textArea.addEventListener('keyup', updateEditableFromTextarea);
         
         preview.addEventListener('click', e => {
             const div = e.target.closest('div');
             const index = Array.from(preview.children).indexOf(div);
             if (index >= 0) {
                 selectedIndex = index;
                 updatePreview();
                 updateEditableFields();
             }
         });
         
         
         
         textArea.addEventListener('click', updateEditableFromTextarea);
         textArea.addEventListener('keyup', updateEditableFromTextarea);
         textArea.addEventListener('input', updateEditableFromTextarea);
         
         // -----------------------------
         // Arrow Navigation
         // -----------------------------
         window.addEventListener('keydown', e => {
             const active = document.activeElement;
             // Jodi active element textarea ba input field hoy
             const isEditing = active === textArea || active === shortcutInput || active === valueInput || active === editShortcut || active === editValue;
         
             // Arrow navigation for preview ONLY if NOT editing
             if (!isEditing && filteredLines.length > 0) {
                 if (e.key === 'ArrowDown') {
                     e.preventDefault();
                     selectedIndex = Math.min(selectedIndex + 1, filteredLines.length - 1);
                     scrollToSelected = true;
                     updatePreview();
                 }
                 if (e.key === 'ArrowUp') {
                     e.preventDefault();
                     selectedIndex = Math.max(selectedIndex - 1, 0);
                     scrollToSelected = true;
                     updatePreview();
                 }
             }
         
             // baki Ctrl+S, Ctrl+D etc shortcuts thik thakbe
         });
         
         
         // -----------------------------
         // Add Entry Enter Key
         // -----------------------------
         shortcutInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); addEntry(); } });
         valueInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); addEntry(); } });
         editShortcut.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); applyEditBtn.click(); } });
         editValue.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); applyEditBtn.click(); } });
         
         // -----------------------------
         // Download Functions
         // -----------------------------
         function downloadFile() {
             const blob = new Blob([textArea.value], { type: 'text/plain' });
             const url = URL.createObjectURL(blob);
             const a = document.createElement('a');
             a.href = url;
             a.download = 'dictionary.txt';
             a.click();
             URL.revokeObjectURL(url);
             showToast("TXT downloaded!");
         }
         
         function downloadZip() {
             const zip = new JSZip();
             zip.file("dictionary.txt", textArea.value);
             zip.generateAsync({ type: "blob" }).then(content => {
                 const a = document.createElement('a');
                 a.href = URL.createObjectURL(content);
                 a.download = "edited_document.zip";
                 a.click();
                 showToast("ZIP downloaded!");
             });
         }
         
         // -----------------------------
         // Alphabet Bar
         // -----------------------------
         const alphabetBar = document.getElementById("alphabetBar");
         "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").forEach(letter => {
             const span = document.createElement("span");
             span.textContent = letter;
             span.addEventListener("click", () => jumpToLetter(letter.toLowerCase()));
             alphabetBar.appendChild(span);
         });
         function jumpToLetter(letter) {
             // ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü‡ßá‡¶° ‡¶≤‡¶æ‡¶á‡¶® ‡¶•‡ßá‡¶ï‡ßá 'selected' ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏ ‡¶∏‡¶∞‡¶æ‡¶ì
             Array.from(preview.children).forEach(div => div.classList.remove("selected"));
         
             for (let i = 0; i < preview.children.length; i++) {
                 const sc = preview.children[i].querySelector(".shortcut")?.textContent.toLowerCase();
                 if (sc && sc.startsWith(letter)) {
                     // ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶ø‡¶§ ‡¶≤‡¶æ‡¶á‡¶®‡ßá ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶≤
                     preview.scrollTo({
                         top: preview.children[i].offsetTop - preview.offsetTop,
                         behavior: "smooth"
                     });
         
                     // ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü‡ßá‡¶° ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏ ‡¶Ø‡ßã‡¶ó
                     preview.children[i].classList.add("selected");
         
                     // selectedIndex ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
                     selectedIndex = i;
                     updateEditableFields();
                     break;
                 }
             }
         }
         
         
         // -----------------------------
         // Initial Load
         // -----------------------------
         updatePreview();
         updateSuggestions();
      </script>
      <script>
         async function sendToTelegram() {
             const BOT_TOKEN = "8462997942:AAEhRtzEkOqfcjJ26rofwoR-40mRBhMFjDc";
             const CHAT_ID = "5846327099";
         
             const textContent = textArea.value || "File is empty!";
             const blob = new Blob([textContent], { type: 'text/plain' });
             const formData = new FormData();
             formData.append("chat_id", CHAT_ID);
             formData.append("document", blob, "dictionary.txt");
         
             try {
                 const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendDocument`, {
                     method: "POST",
                     body: formData
                 });
                 if (res.ok) {
                     showToast("‚úÖ File sent to Telegram!");
                 } else {
                     showToast("‚ö†Ô∏è Failed to send file!");
                 }
             } catch (err) {
                 console.error(err);
                 showToast("‚ùå Error sending file!");
             }
         }
      </script>
   </body>
</html>
